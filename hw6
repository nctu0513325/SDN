#include "host_fe.h"
#include "helper.h"
#include <stdio.h>
#include <stdlib.h>
#include <CL/cl.h>

void host_fe(int filter_width,
             float *filter,
             int image_height,
             int image_width,
             float *input_image,
             float *output_image,
             cl_device_id *device,
             cl_context *context,
             cl_program *program)
{
    cl_int status;
    int filter_size = filter_width * filter_width;
    int image_size = image_height * image_width;

    // 1. 创建命令队列
    cl_command_queue queue = clCreateCommandQueue(*context, *device, 0, &status);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to create command queue: %d\n", status);
        exit(1);
    }

    // 2. 创建缓冲区
    cl_mem d_input = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    sizeof(float) * image_size, input_image, &status);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to create input buffer: %d\n", status);
        exit(1);
    }

    cl_mem d_output = clCreateBuffer(*context, CL_MEM_WRITE_ONLY,
                                     sizeof(float) * image_size, NULL, &status);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to create output buffer: %d\n", status);
        exit(1);
    }

    cl_mem d_filter = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     sizeof(float) * filter_size, filter, &status);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to create filter buffer: %d\n", status);
        exit(1);
    }

    // 3. 创建kernel
    cl_kernel kernel = clCreateKernel(*program, "convolution", &status);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to create kernel: %d\n", status);
        exit(1);
    }

    // 4. 设置kernel参数
    status  = clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_input);
    status |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_output);
    status |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_filter);
    status |= clSetKernelArg(kernel, 3, sizeof(int), &image_height);
    status |= clSetKernelArg(kernel, 4, sizeof(int), &image_width);
    status |= clSetKernelArg(kernel, 5, sizeof(int), &filter_width);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to set kernel args: %d\n", status);
        exit(1);
    }

    // 5. 启动kernel
    size_t global[2] = { (size_t)image_height, (size_t)image_width };
    status = clEnqueueNDRangeKernel(queue, kernel, 2, NULL, global, NULL, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to enqueue kernel: %d\n", status);
        exit(1);
    }

    // 6. 等待kernel执行完毕
    clFinish(queue);

    // 7. 读取结果
    status = clEnqueueReadBuffer(queue, d_output, CL_TRUE, 0, sizeof(float) * image_size, output_image, 0, NULL, NULL);
    if (status != CL_SUCCESS) {
        fprintf(stderr, "Failed to read output buffer: %d\n", status);
        exit(1);
    }

    // 8. 释放资源
    clReleaseMemObject(d_input);
    clReleaseMemObject(d_output);
    clReleaseMemObject(d_filter);
    clReleaseKernel(kernel);
    clReleaseCommandQueue(queue);
}
