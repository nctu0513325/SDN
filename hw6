void host_fe(int filter_width,
             float *filter,
             int image_height,
             int image_width,
             float *input_image,
             float *output_image,
             cl_device_id *device,
             cl_context *context,
             cl_program *program)
{
    cl_int status;
    int filter_size = filter_width * filter_width;
    int image_size = image_height * image_width;

    // 1. Create buffers
    cl_mem d_input = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    sizeof(float) * image_size, input_image, &status);
    cl_mem d_output = clCreateBuffer(*context, CL_MEM_WRITE_ONLY,
                                     sizeof(float) * image_size, NULL, &status);
    cl_mem d_filter = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     sizeof(float) * filter_size, filter, &status);

    // 2. Create kernel
    cl_kernel kernel = clCreateKernel(*program, "convolution", &status);

    // 3. Set kernel arguments
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_input);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_output);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_filter);
    clSetKernelArg(kernel, 3, sizeof(int), &image_height);
    clSetKernelArg(kernel, 4, sizeof(int), &image_width);
    clSetKernelArg(kernel, 5, sizeof(int), &filter_width);

    // 4. Launch kernel
    size_t global[2] = {image_height, image_width};
    cl_command_queue queue = clCreateCommandQueue(*context, *device, 0, &status);
    clEnqueueNDRangeKernel(queue, kernel, 2, NULL, global, NULL, 0, NULL, NULL);

    // 5. Read back result
    clEnqueueReadBuffer(queue, d_output, CL_TRUE, 0, sizeof(float) * image_size, output_image, 0, NULL, NULL);

    // 6. Cleanup
    clReleaseMemObject(d_input);
    clReleaseMemObject(d_output);
    clReleaseMemObject(d_filter);
    clReleaseKernel(kernel);
    clReleaseCommandQueue(queue);
}void host_fe(int filter_width,
             float *filter,
             int image_height,
             int image_width,
             float *input_image,
             float *output_image,
             cl_device_id *device,
             cl_context *context,
             cl_program *program)
{
    cl_int status;
    int filter_size = filter_width * filter_width;
    int image_size = image_height * image_width;

    // 1. Create buffers
    cl_mem d_input = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                    sizeof(float) * image_size, input_image, &status);
    cl_mem d_output = clCreateBuffer(*context, CL_MEM_WRITE_ONLY,
                                     sizeof(float) * image_size, NULL, &status);
    cl_mem d_filter = clCreateBuffer(*context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                     sizeof(float) * filter_size, filter, &status);

    // 2. Create kernel
    cl_kernel kernel = clCreateKernel(*program, "convolution", &status);

    // 3. Set kernel arguments
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_input);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_output);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_filter);
    clSetKernelArg(kernel, 3, sizeof(int), &image_height);
    clSetKernelArg(kernel, 4, sizeof(int), &image_width);
    clSetKernelArg(kernel, 5, sizeof(int), &filter_width);

    // 4. Launch kernel
    size_t global[2] = {image_height, image_width};
    cl_command_queue queue = clCreateCommandQueue(*context, *device, 0, &status);
    clEnqueueNDRangeKernel(queue, kernel, 2, NULL, global, NULL, 0, NULL, NULL);

    // 5. Read back result
    clEnqueueReadBuffer(queue, d_output, CL_TRUE, 0, sizeof(float) * image_size, output_image, 0, NULL, NULL);

    // 6. Cleanup
    clReleaseMemObject(d_input);
    clReleaseMemObject(d_output);
    clReleaseMemObject(d_filter);
    clReleaseKernel(kernel);
    clReleaseCommandQueue(queue);
}

__kernel void convolution(
    __global const float* input,
    __global float* output,
    __global const float* filter,
    int image_height,
    int image_width,
    int filter_width)
{
    int y = get_global_id(0);
    int x = get_global_id(1);

    int half = filter_width / 2;
    float sum = 0.0f;

    for (int fy = 0; fy < filter_width; fy++) {
        for (int fx = 0; fx < filter_width; fx++) {
            int iy = y + fy - half;
            int ix = x + fx - half;
            if (iy >= 0 && iy < image_height && ix >= 0 && ix < image_width) {
                sum += input[iy * image_width + ix] * filter[fy * filter_width + fx];
            }
        }
    }
    output[y * image_width + x] = sum__kernel void convolution(
    __global const float* input,
    __global float* output,
    __global const float* filter,
    int image_height,
    int image_width,
    int filter_width)
{
    int y = get_global_id(0);
    int x = get_global_id(1);

    int half = filter_width / 2;
    float sum = 0.0f;

    for (int fy = 0; fy < filter_width; fy++) {
        for (int fx = 0; fx < filter_width; fx++) {
            int iy = y + fy - half;
            int ix = x + fx - half;
            if (iy >= 0 && iy < image_height && ix >= 0 && ix < image_width) {
                sum += input[iy * image_width + ix] * filter[fy * filter_width + fx];
            }
        }
    }
    output[y * image_width + x] = sum;
};
}
